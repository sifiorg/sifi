{
  "address": "0xBc3DF9Aa6223128F517fDb3C93d51B1a28F0f96A",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_addressesLength",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_calldataLength",
          "type": "uint256"
        }
      ],
      "name": "AddressAndCalldataLengthDoNotMatch",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_initializationContractAddress",
          "type": "address"
        },
        {
          "internalType": "bytes",
          "name": "_calldata",
          "type": "bytes"
        }
      ],
      "name": "InitializationFunctionReverted",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address[]",
          "name": "_addresses",
          "type": "address[]"
        },
        {
          "internalType": "bytes[]",
          "name": "_calldata",
          "type": "bytes[]"
        }
      ],
      "name": "multiInit",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0x2dc24a2d6fef359a8fd538b13bcb299592d86698b32a795a4cc3e0c581211809",
  "receipt": {
    "to": null,
    "from": "0x67E21394bBC46c010D9B8DCf00172Ab7996964BE",
    "contractAddress": "0xBc3DF9Aa6223128F517fDb3C93d51B1a28F0f96A",
    "transactionIndex": 97,
    "gasUsed": "351086",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x74519786b0641f797cde619d2562f526f4a727097cabb488be232561e22eacc2",
    "transactionHash": "0x2dc24a2d6fef359a8fd538b13bcb299592d86698b32a795a4cc3e0c581211809",
    "logs": [],
    "blockNumber": 18075509,
    "cumulativeGasUsed": "6643681",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 2,
  "solcInputHash": "b3e79b299ff67309e24953e67dc08b9d",
  "metadata": "{\"compiler\":{\"version\":\"0.8.21+commit.d9974bed\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_addressesLength\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_calldataLength\",\"type\":\"uint256\"}],\"name\":\"AddressAndCalldataLengthDoNotMatch\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_initializationContractAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_calldata\",\"type\":\"bytes\"}],\"name\":\"InitializationFunctionReverted\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_addresses\",\"type\":\"address[]\"},{\"internalType\":\"bytes[]\",\"name\":\"_calldata\",\"type\":\"bytes[]\"}],\"name\":\"multiInit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/init/DiamondMultiInit.sol\":\"DiamondMultiInit\"},\"evmVersion\":\"shanghai\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":999999},\"remappings\":[\":@openzeppelin/=@openzeppelin/\",\":@uniswap/=@uniswap/\",\":ds-test/=lib/forge-std/lib/ds-test/src/\",\":forge-std/=lib/forge-std/src/\",\":hardhat-deploy/=hardhat-deploy/\",\":hardhat/=hardhat/\",\":solidity-stringutils/=lib/solidity-stringutils/src/\"]},\"sources\":{\"contracts/init/DiamondMultiInit.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// From https://github.com/mudgen/diamond-1-hardhat/blob/main/contracts/upgradeInitializers/DiamondMultiInit.sol\\npragma solidity ^0.8.0;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\n*\\n* Implementation of a diamond.\\n/******************************************************************************/\\n\\nimport {LibDiamond} from '../libraries/LibDiamond.sol';\\n\\nerror AddressAndCalldataLengthDoNotMatch(uint256 _addressesLength, uint256 _calldataLength);\\n\\ncontract DiamondMultiInit {\\n  // This function is provided in the third parameter of the `diamondCut` function.\\n  // The `diamondCut` function executes this function to execute multiple initializer functions for a single upgrade.\\n\\n  function multiInit(address[] calldata _addresses, bytes[] calldata _calldata) external {\\n    if (_addresses.length != _calldata.length) {\\n      revert AddressAndCalldataLengthDoNotMatch(_addresses.length, _calldata.length);\\n    }\\n    for (uint i; i < _addresses.length; i++) {\\n      LibDiamond.initializeDiamondCut(_addresses[i], _calldata[i]);\\n    }\\n  }\\n}\\n\",\"keccak256\":\"0x2778f73f129aeff0fdbc1ede69ce34241f9de2f2059c51963ac0ee21825893d8\",\"license\":\"MIT\"},\"contracts/interfaces/IDiamondCut.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\n\\ninterface IDiamondCut {\\n  enum FacetCutAction {\\n    Add,\\n    Replace,\\n    Remove\\n  }\\n  // Add=0, Replace=1, Remove=2\\n\\n  struct FacetCut {\\n    address facetAddress;\\n    FacetCutAction action;\\n    bytes4[] functionSelectors;\\n  }\\n\\n  /// @notice Add/replace/remove any number of functions and optionally execute\\n  ///         a function with delegatecall\\n  /// @param _diamondCut Contains the facet addresses and function selectors\\n  /// @param _init The address of the contract or facet to execute _calldata\\n  /// @param _calldata A function call, including function selector and arguments\\n  ///                  _calldata is executed with delegatecall on _init\\n  function diamondCut(\\n    FacetCut[] calldata _diamondCut,\\n    address _init,\\n    bytes calldata _calldata\\n  ) external;\\n\\n  event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\\n}\\n\",\"keccak256\":\"0x2542d3d1dc26be46c0c298c6c7a1ac7943fd920dd2ac7cc013fe775e36ba973a\",\"license\":\"MIT\"},\"contracts/libraries/LibDiamond.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.21;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\nimport {IDiamondCut} from '../interfaces/IDiamondCut.sol';\\n\\n// Remember to add the loupe functions from DiamondLoupeFacet to the diamond.\\n// The loupe functions are required by the EIP2535 Diamonds standard\\n\\nerror InitializationFunctionReverted(address _initializationContractAddress, bytes _calldata);\\n\\nlibrary LibDiamond {\\n  bytes32 constant DIAMOND_STORAGE_POSITION = keccak256('diamond.standard.diamond.storage');\\n\\n  struct FacetAddressAndPosition {\\n    address facetAddress;\\n    uint96 functionSelectorPosition; // position in facetFunctionSelectors.functionSelectors array\\n  }\\n\\n  struct FacetFunctionSelectors {\\n    bytes4[] functionSelectors;\\n    uint256 facetAddressPosition; // position of facetAddress in facetAddresses array\\n  }\\n\\n  struct DiamondStorage {\\n    // maps function selector to the facet address and\\n    // the position of the selector in the facetFunctionSelectors.selectors array\\n    mapping(bytes4 => FacetAddressAndPosition) selectorToFacetAndPosition;\\n    // maps facet addresses to function selectors\\n    mapping(address => FacetFunctionSelectors) facetFunctionSelectors;\\n    // facet addresses\\n    address[] facetAddresses;\\n    address contractOwner;\\n  }\\n\\n  function diamondStorage() internal pure returns (DiamondStorage storage ds) {\\n    bytes32 position = DIAMOND_STORAGE_POSITION;\\n    assembly {\\n      ds.slot := position\\n    }\\n  }\\n\\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n  function setContractOwner(address _newOwner) internal {\\n    DiamondStorage storage ds = diamondStorage();\\n    address previousOwner = ds.contractOwner;\\n    ds.contractOwner = _newOwner;\\n    emit OwnershipTransferred(previousOwner, _newOwner);\\n  }\\n\\n  function contractOwner() internal view returns (address contractOwner_) {\\n    contractOwner_ = diamondStorage().contractOwner;\\n  }\\n\\n  function enforceIsContractOwner() internal view {\\n    require(msg.sender == diamondStorage().contractOwner, 'LibDiamond: Must be contract owner');\\n  }\\n\\n  event DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\\n\\n  // Internal function version of diamondCut\\n  function diamondCut(\\n    IDiamondCut.FacetCut[] memory _diamondCut,\\n    address _init,\\n    bytes memory _calldata\\n  ) internal {\\n    for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\\n      IDiamondCut.FacetCutAction action = _diamondCut[facetIndex].action;\\n      if (action == IDiamondCut.FacetCutAction.Add) {\\n        addFunctions(\\n          _diamondCut[facetIndex].facetAddress,\\n          _diamondCut[facetIndex].functionSelectors\\n        );\\n      } else if (action == IDiamondCut.FacetCutAction.Replace) {\\n        replaceFunctions(\\n          _diamondCut[facetIndex].facetAddress,\\n          _diamondCut[facetIndex].functionSelectors\\n        );\\n      } else if (action == IDiamondCut.FacetCutAction.Remove) {\\n        removeFunctions(\\n          _diamondCut[facetIndex].facetAddress,\\n          _diamondCut[facetIndex].functionSelectors\\n        );\\n      } else {\\n        revert('LibDiamondCut: Incorrect FacetCutAction');\\n      }\\n    }\\n    emit DiamondCut(_diamondCut, _init, _calldata);\\n    initializeDiamondCut(_init, _calldata);\\n  }\\n\\n  function addFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\\n    require(_functionSelectors.length > 0, 'LibDiamondCut: No selectors in facet to cut');\\n    DiamondStorage storage ds = diamondStorage();\\n    require(_facetAddress != address(0), \\\"LibDiamondCut: Add facet can't be address(0)\\\");\\n    uint96 selectorPosition = uint96(\\n      ds.facetFunctionSelectors[_facetAddress].functionSelectors.length\\n    );\\n    // add new facet address if it does not exist\\n    if (selectorPosition == 0) {\\n      addFacet(ds, _facetAddress);\\n    }\\n    for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\n      bytes4 selector = _functionSelectors[selectorIndex];\\n      address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\\n      require(\\n        oldFacetAddress == address(0),\\n        \\\"LibDiamondCut: Can't add function that already exists\\\"\\n      );\\n      addFunction(ds, selector, selectorPosition, _facetAddress);\\n      selectorPosition++;\\n    }\\n  }\\n\\n  function replaceFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\\n    require(_functionSelectors.length > 0, 'LibDiamondCut: No selectors in facet to cut');\\n    DiamondStorage storage ds = diamondStorage();\\n    require(_facetAddress != address(0), \\\"LibDiamondCut: Add facet can't be address(0)\\\");\\n    uint96 selectorPosition = uint96(\\n      ds.facetFunctionSelectors[_facetAddress].functionSelectors.length\\n    );\\n    // add new facet address if it does not exist\\n    if (selectorPosition == 0) {\\n      addFacet(ds, _facetAddress);\\n    }\\n    for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\n      bytes4 selector = _functionSelectors[selectorIndex];\\n      address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\\n      require(\\n        oldFacetAddress != _facetAddress,\\n        \\\"LibDiamondCut: Can't replace function with same function\\\"\\n      );\\n      removeFunction(ds, oldFacetAddress, selector);\\n      addFunction(ds, selector, selectorPosition, _facetAddress);\\n      selectorPosition++;\\n    }\\n  }\\n\\n  function removeFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\\n    require(_functionSelectors.length > 0, 'LibDiamondCut: No selectors in facet to cut');\\n    DiamondStorage storage ds = diamondStorage();\\n    // if function does not exist then do nothing and return\\n    require(_facetAddress == address(0), 'LibDiamondCut: Remove facet address must be address(0)');\\n    for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\n      bytes4 selector = _functionSelectors[selectorIndex];\\n      address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\\n      removeFunction(ds, oldFacetAddress, selector);\\n    }\\n  }\\n\\n  function addFacet(DiamondStorage storage ds, address _facetAddress) internal {\\n    enforceHasContractCode(_facetAddress, 'LibDiamondCut: New facet has no code');\\n    ds.facetFunctionSelectors[_facetAddress].facetAddressPosition = ds.facetAddresses.length;\\n    ds.facetAddresses.push(_facetAddress);\\n  }\\n\\n  function addFunction(\\n    DiamondStorage storage ds,\\n    bytes4 _selector,\\n    uint96 _selectorPosition,\\n    address _facetAddress\\n  ) internal {\\n    ds.selectorToFacetAndPosition[_selector].functionSelectorPosition = _selectorPosition;\\n    ds.facetFunctionSelectors[_facetAddress].functionSelectors.push(_selector);\\n    ds.selectorToFacetAndPosition[_selector].facetAddress = _facetAddress;\\n  }\\n\\n  function removeFunction(\\n    DiamondStorage storage ds,\\n    address _facetAddress,\\n    bytes4 _selector\\n  ) internal {\\n    require(_facetAddress != address(0), \\\"LibDiamondCut: Can't remove function that doesn't exist\\\");\\n    // an immutable function is a function defined directly in a diamond\\n    require(_facetAddress != address(this), \\\"LibDiamondCut: Can't remove immutable function\\\");\\n    // replace selector with last selector, then delete last selector\\n    uint256 selectorPosition = ds.selectorToFacetAndPosition[_selector].functionSelectorPosition;\\n    uint256 lastSelectorPosition = ds\\n      .facetFunctionSelectors[_facetAddress]\\n      .functionSelectors\\n      .length - 1;\\n    // if not the same then replace _selector with lastSelector\\n    if (selectorPosition != lastSelectorPosition) {\\n      bytes4 lastSelector = ds.facetFunctionSelectors[_facetAddress].functionSelectors[\\n        lastSelectorPosition\\n      ];\\n      ds.facetFunctionSelectors[_facetAddress].functionSelectors[selectorPosition] = lastSelector;\\n      ds.selectorToFacetAndPosition[lastSelector].functionSelectorPosition = uint96(\\n        selectorPosition\\n      );\\n    }\\n    // delete the last selector\\n    ds.facetFunctionSelectors[_facetAddress].functionSelectors.pop();\\n    delete ds.selectorToFacetAndPosition[_selector];\\n\\n    // if no more selectors for facet address then delete the facet address\\n    if (lastSelectorPosition == 0) {\\n      // replace facet address with last facet address and delete last facet address\\n      uint256 lastFacetAddressPosition = ds.facetAddresses.length - 1;\\n      uint256 facetAddressPosition = ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\\n      if (facetAddressPosition != lastFacetAddressPosition) {\\n        address lastFacetAddress = ds.facetAddresses[lastFacetAddressPosition];\\n        ds.facetAddresses[facetAddressPosition] = lastFacetAddress;\\n        ds.facetFunctionSelectors[lastFacetAddress].facetAddressPosition = facetAddressPosition;\\n      }\\n      ds.facetAddresses.pop();\\n      delete ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\\n    }\\n  }\\n\\n  function initializeDiamondCut(address _init, bytes memory _calldata) internal {\\n    if (_init == address(0)) {\\n      return;\\n    }\\n    enforceHasContractCode(_init, 'LibDiamondCut: _init address has no code');\\n    (bool success, bytes memory error) = _init.delegatecall(_calldata);\\n    if (!success) {\\n      if (error.length > 0) {\\n        // bubble up error\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n          let returndata_size := mload(error)\\n          revert(add(32, error), returndata_size)\\n        }\\n      } else {\\n        revert InitializationFunctionReverted(_init, _calldata);\\n      }\\n    }\\n  }\\n\\n  function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\\n    uint256 contractSize;\\n    assembly {\\n      contractSize := extcodesize(_contract)\\n    }\\n    require(contractSize > 0, _errorMessage);\\n  }\\n}\\n\",\"keccak256\":\"0x9eabc2f173dd41dd854a07d985ede09cfa8f01761eb8565a533a6bb8881761e6\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x608060405234801561000f575f80fd5b506105698061001d5f395ff3fe608060405234801561000f575f80fd5b5060043610610029575f3560e01c80636e02fa3c1461002d575b5f80fd5b61004061003b3660046102b2565b610042565b005b82811461008a576040517f7340e16600000000000000000000000000000000000000000000000000000000815260048101849052602481018290526044015b60405180910390fd5b5f5b8381101561012d5761011b8585838181106100a9576100a9610319565b90506020020160208101906100be9190610346565b8484848181106100d0576100d0610319565b90506020028101906100e29190610380565b8080601f0160208091040260200160405190810160405280939291908181526020018383808284375f9201919091525061013492505050565b80610125816103e1565b91505061008c565b5050505050565b73ffffffffffffffffffffffffffffffffffffffff8216610153575050565b6101758260405180606001604052806028815260200161050c6028913961022f565b5f808373ffffffffffffffffffffffffffffffffffffffff168360405161019c919061045f565b5f60405180830381855af49150503d805f81146101d4576040519150601f19603f3d011682016040523d82523d5f602084013e6101d9565b606091505b509150915081610229578051156101f35780518082602001fd5b83836040517f192105d70000000000000000000000000000000000000000000000000000000081526004016100819291906104c3565b50505050565b813b8181610229576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161008191906104f9565b5f8083601f84011261027a575f80fd5b50813567ffffffffffffffff811115610291575f80fd5b6020830191508360208260051b85010111156102ab575f80fd5b9250929050565b5f805f80604085870312156102c5575f80fd5b843567ffffffffffffffff808211156102dc575f80fd5b6102e88883890161026a565b90965094506020870135915080821115610300575f80fd5b5061030d8782880161026a565b95989497509550505050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52603260045260245ffd5b5f60208284031215610356575f80fd5b813573ffffffffffffffffffffffffffffffffffffffff81168114610379575f80fd5b9392505050565b5f8083357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe18436030181126103b3575f80fd5b83018035915067ffffffffffffffff8211156103cd575f80fd5b6020019150368190038213156102ab575f80fd5b5f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8203610436577f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b5060010190565b5f5b8381101561045757818101518382015260200161043f565b50505f910152565b5f825161047081846020870161043d565b9190910192915050565b5f815180845261049181602086016020860161043d565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169290920160200192915050565b73ffffffffffffffffffffffffffffffffffffffff83168152604060208201525f6104f1604083018461047a565b949350505050565b602081525f610379602083018461047a56fe4c69624469616d6f6e644375743a205f696e6974206164647265737320686173206e6f20636f6465a2646970667358221220324e029d24bbe7c4e5a8f674242723cf36a97c6ba780a1ff99d7c96332ec897264736f6c63430008150033",
  "deployedBytecode": "0x608060405234801561000f575f80fd5b5060043610610029575f3560e01c80636e02fa3c1461002d575b5f80fd5b61004061003b3660046102b2565b610042565b005b82811461008a576040517f7340e16600000000000000000000000000000000000000000000000000000000815260048101849052602481018290526044015b60405180910390fd5b5f5b8381101561012d5761011b8585838181106100a9576100a9610319565b90506020020160208101906100be9190610346565b8484848181106100d0576100d0610319565b90506020028101906100e29190610380565b8080601f0160208091040260200160405190810160405280939291908181526020018383808284375f9201919091525061013492505050565b80610125816103e1565b91505061008c565b5050505050565b73ffffffffffffffffffffffffffffffffffffffff8216610153575050565b6101758260405180606001604052806028815260200161050c6028913961022f565b5f808373ffffffffffffffffffffffffffffffffffffffff168360405161019c919061045f565b5f60405180830381855af49150503d805f81146101d4576040519150601f19603f3d011682016040523d82523d5f602084013e6101d9565b606091505b509150915081610229578051156101f35780518082602001fd5b83836040517f192105d70000000000000000000000000000000000000000000000000000000081526004016100819291906104c3565b50505050565b813b8181610229576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161008191906104f9565b5f8083601f84011261027a575f80fd5b50813567ffffffffffffffff811115610291575f80fd5b6020830191508360208260051b85010111156102ab575f80fd5b9250929050565b5f805f80604085870312156102c5575f80fd5b843567ffffffffffffffff808211156102dc575f80fd5b6102e88883890161026a565b90965094506020870135915080821115610300575f80fd5b5061030d8782880161026a565b95989497509550505050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52603260045260245ffd5b5f60208284031215610356575f80fd5b813573ffffffffffffffffffffffffffffffffffffffff81168114610379575f80fd5b9392505050565b5f8083357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe18436030181126103b3575f80fd5b83018035915067ffffffffffffffff8211156103cd575f80fd5b6020019150368190038213156102ab575f80fd5b5f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8203610436577f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b5060010190565b5f5b8381101561045757818101518382015260200161043f565b50505f910152565b5f825161047081846020870161043d565b9190910192915050565b5f815180845261049181602086016020860161043d565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169290920160200192915050565b73ffffffffffffffffffffffffffffffffffffffff83168152604060208201525f6104f1604083018461047a565b949350505050565b602081525f610379602083018461047a56fe4c69624469616d6f6e644375743a205f696e6974206164647265737320686173206e6f20636f6465a2646970667358221220324e029d24bbe7c4e5a8f674242723cf36a97c6ba780a1ff99d7c96332ec897264736f6c63430008150033",
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}