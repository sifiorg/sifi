{
  "address": "0x71e0BD402c5C0B61dE1D224824c551fE0D623065",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_addressesLength",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_calldataLength",
          "type": "uint256"
        }
      ],
      "name": "AddressAndCalldataLengthDoNotMatch",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_initializationContractAddress",
          "type": "address"
        },
        {
          "internalType": "bytes",
          "name": "_calldata",
          "type": "bytes"
        }
      ],
      "name": "InitializationFunctionReverted",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address[]",
          "name": "_addresses",
          "type": "address[]"
        },
        {
          "internalType": "bytes[]",
          "name": "_calldata",
          "type": "bytes[]"
        }
      ],
      "name": "multiInit",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0xf837971828e95336e14cd639507eb51b909690cfe8021c7ae94deca3a9a44dd2",
  "receipt": {
    "to": null,
    "from": "0x67E21394bBC46c010D9B8DCf00172Ab7996964BE",
    "contractAddress": "0x71e0BD402c5C0B61dE1D224824c551fE0D623065",
    "transactionIndex": 82,
    "gasUsed": "358372",
    "logsBloom": "0x00000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000008400000000000000000000000000000000000000000000000000000000800000000800000000000100000000000000000000000000000001000000000040000000000000000080000000000000000000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000004000000000000000000001000000000000000000000000000000100000000000000000000000000000000000000000000200000000000000000000000000100000",
    "blockHash": "0xe13c39a4dead8d83c04a6b443639e524e0691e9bf4ce3a706b4120babd6cdb43",
    "transactionHash": "0xf837971828e95336e14cd639507eb51b909690cfe8021c7ae94deca3a9a44dd2",
    "logs": [
      {
        "transactionIndex": 82,
        "blockNumber": 47996603,
        "transactionHash": "0xf837971828e95336e14cd639507eb51b909690cfe8021c7ae94deca3a9a44dd2",
        "address": "0x0000000000000000000000000000000000001010",
        "topics": [
          "0x4dfe1bbbcf077ddc3e01291eea2d5c70c2b422b415d95645b9adcfd678cb1d63",
          "0x0000000000000000000000000000000000000000000000000000000000001010",
          "0x00000000000000000000000067e21394bbc46c010d9b8dcf00172ab7996964be",
          "0x000000000000000000000000eb4f2a75cac4bbcb4d71c252e4cc80eb80bb3a34"
        ],
        "data": "0x0000000000000000000000000000000000000000000000000000e7b8b31d09a000000000000000000000000000000000000000000000000539e11d864800afc3000000000000000000000000000000000000000000000aabd3ed091c32a72d2f00000000000000000000000000000000000000000000000539e035cd94e3a623000000000000000000000000000000000000000000000aabd3edf0d4e5c436cf",
        "logIndex": 360,
        "blockHash": "0xe13c39a4dead8d83c04a6b443639e524e0691e9bf4ce3a706b4120babd6cdb43"
      }
    ],
    "blockNumber": 47996603,
    "cumulativeGasUsed": "22833210",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 2,
  "solcInputHash": "4bd33b0efaadcd28492d25c3625ab942",
  "metadata": "{\"compiler\":{\"version\":\"0.8.19+commit.7dd6d404\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_addressesLength\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_calldataLength\",\"type\":\"uint256\"}],\"name\":\"AddressAndCalldataLengthDoNotMatch\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_initializationContractAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_calldata\",\"type\":\"bytes\"}],\"name\":\"InitializationFunctionReverted\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_addresses\",\"type\":\"address[]\"},{\"internalType\":\"bytes[]\",\"name\":\"_calldata\",\"type\":\"bytes[]\"}],\"name\":\"multiInit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/init/DiamondMultiInit.sol\":\"DiamondMultiInit\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":999999},\"remappings\":[\":@openzeppelin/=@openzeppelin/\",\":@uniswap/=@uniswap/\",\":ds-test/=lib/forge-std/lib/ds-test/src/\",\":forge-std/=lib/forge-std/src/\",\":hardhat-deploy/=hardhat-deploy/\",\":hardhat/=hardhat/\",\":solidity-stringutils/=lib/solidity-stringutils/src/\"]},\"sources\":{\"contracts/init/DiamondMultiInit.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\n// From https://github.com/mudgen/diamond-1-hardhat/blob/main/contracts/upgradeInitializers/DiamondMultiInit.sol\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\n*\\n* Implementation of a diamond.\\n/******************************************************************************/\\n\\nimport {LibDiamond} from '../libraries/LibDiamond.sol';\\n\\nerror AddressAndCalldataLengthDoNotMatch(uint256 _addressesLength, uint256 _calldataLength);\\n\\ncontract DiamondMultiInit {\\n  // This function is provided in the third parameter of the `diamondCut` function.\\n  // The `diamondCut` function executes this function to execute multiple initializer functions for a single upgrade.\\n\\n  function multiInit(address[] calldata _addresses, bytes[] calldata _calldata) external {\\n    if (_addresses.length != _calldata.length) {\\n      revert AddressAndCalldataLengthDoNotMatch(_addresses.length, _calldata.length);\\n    }\\n    for (uint i; i < _addresses.length; i++) {\\n      LibDiamond.initializeDiamondCut(_addresses[i], _calldata[i]);\\n    }\\n  }\\n}\\n\",\"keccak256\":\"0x8a6197389eba7856703a1fbabf7ecdd760678fcaf61be646731a14e4f88e80e9\",\"license\":\"MIT\"},\"contracts/interfaces/IDiamondCut.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\n\\ninterface IDiamondCut {\\n  enum FacetCutAction {\\n    Add,\\n    Replace,\\n    Remove\\n  }\\n  // Add=0, Replace=1, Remove=2\\n\\n  struct FacetCut {\\n    address facetAddress;\\n    FacetCutAction action;\\n    bytes4[] functionSelectors;\\n  }\\n\\n  /// @notice Add/replace/remove any number of functions and optionally execute\\n  ///         a function with delegatecall\\n  /// @param _diamondCut Contains the facet addresses and function selectors\\n  /// @param _init The address of the contract or facet to execute _calldata\\n  /// @param _calldata A function call, including function selector and arguments\\n  ///                  _calldata is executed with delegatecall on _init\\n  function diamondCut(\\n    FacetCut[] calldata _diamondCut,\\n    address _init,\\n    bytes calldata _calldata\\n  ) external;\\n\\n  event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\\n}\\n\",\"keccak256\":\"0x2542d3d1dc26be46c0c298c6c7a1ac7943fd920dd2ac7cc013fe775e36ba973a\",\"license\":\"MIT\"},\"contracts/libraries/LibDiamond.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\nimport {IDiamondCut} from '../interfaces/IDiamondCut.sol';\\n\\n// Remember to add the loupe functions from DiamondLoupeFacet to the diamond.\\n// The loupe functions are required by the EIP2535 Diamonds standard\\n\\nerror InitializationFunctionReverted(address _initializationContractAddress, bytes _calldata);\\n\\nlibrary LibDiamond {\\n  bytes32 constant DIAMOND_STORAGE_POSITION = keccak256('diamond.standard.diamond.storage');\\n\\n  struct FacetAddressAndPosition {\\n    address facetAddress;\\n    uint96 functionSelectorPosition; // position in facetFunctionSelectors.functionSelectors array\\n  }\\n\\n  struct FacetFunctionSelectors {\\n    bytes4[] functionSelectors;\\n    uint256 facetAddressPosition; // position of facetAddress in facetAddresses array\\n  }\\n\\n  struct DiamondStorage {\\n    // maps function selector to the facet address and\\n    // the position of the selector in the facetFunctionSelectors.selectors array\\n    mapping(bytes4 => FacetAddressAndPosition) selectorToFacetAndPosition;\\n    // maps facet addresses to function selectors\\n    mapping(address => FacetFunctionSelectors) facetFunctionSelectors;\\n    // facet addresses\\n    address[] facetAddresses;\\n    address contractOwner;\\n  }\\n\\n  function diamondStorage() internal pure returns (DiamondStorage storage ds) {\\n    bytes32 position = DIAMOND_STORAGE_POSITION;\\n    assembly {\\n      ds.slot := position\\n    }\\n  }\\n\\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n  function setContractOwner(address _newOwner) internal {\\n    DiamondStorage storage ds = diamondStorage();\\n    address previousOwner = ds.contractOwner;\\n    ds.contractOwner = _newOwner;\\n    emit OwnershipTransferred(previousOwner, _newOwner);\\n  }\\n\\n  function contractOwner() internal view returns (address contractOwner_) {\\n    contractOwner_ = diamondStorage().contractOwner;\\n  }\\n\\n  function enforceIsContractOwner() internal view {\\n    require(msg.sender == diamondStorage().contractOwner, 'LibDiamond: Must be contract owner');\\n  }\\n\\n  event DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\\n\\n  // Internal function version of diamondCut\\n  function diamondCut(\\n    IDiamondCut.FacetCut[] memory _diamondCut,\\n    address _init,\\n    bytes memory _calldata\\n  ) internal {\\n    for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\\n      IDiamondCut.FacetCutAction action = _diamondCut[facetIndex].action;\\n      if (action == IDiamondCut.FacetCutAction.Add) {\\n        addFunctions(\\n          _diamondCut[facetIndex].facetAddress,\\n          _diamondCut[facetIndex].functionSelectors\\n        );\\n      } else if (action == IDiamondCut.FacetCutAction.Replace) {\\n        replaceFunctions(\\n          _diamondCut[facetIndex].facetAddress,\\n          _diamondCut[facetIndex].functionSelectors\\n        );\\n      } else if (action == IDiamondCut.FacetCutAction.Remove) {\\n        removeFunctions(\\n          _diamondCut[facetIndex].facetAddress,\\n          _diamondCut[facetIndex].functionSelectors\\n        );\\n      } else {\\n        revert('LibDiamondCut: Incorrect FacetCutAction');\\n      }\\n    }\\n    emit DiamondCut(_diamondCut, _init, _calldata);\\n    initializeDiamondCut(_init, _calldata);\\n  }\\n\\n  function addFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\\n    require(_functionSelectors.length > 0, 'LibDiamondCut: No selectors in facet to cut');\\n    DiamondStorage storage ds = diamondStorage();\\n    require(_facetAddress != address(0), \\\"LibDiamondCut: Add facet can't be address(0)\\\");\\n    uint96 selectorPosition = uint96(\\n      ds.facetFunctionSelectors[_facetAddress].functionSelectors.length\\n    );\\n    // add new facet address if it does not exist\\n    if (selectorPosition == 0) {\\n      addFacet(ds, _facetAddress);\\n    }\\n    for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\n      bytes4 selector = _functionSelectors[selectorIndex];\\n      address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\\n      require(\\n        oldFacetAddress == address(0),\\n        \\\"LibDiamondCut: Can't add function that already exists\\\"\\n      );\\n      addFunction(ds, selector, selectorPosition, _facetAddress);\\n      selectorPosition++;\\n    }\\n  }\\n\\n  function replaceFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\\n    require(_functionSelectors.length > 0, 'LibDiamondCut: No selectors in facet to cut');\\n    DiamondStorage storage ds = diamondStorage();\\n    require(_facetAddress != address(0), \\\"LibDiamondCut: Add facet can't be address(0)\\\");\\n    uint96 selectorPosition = uint96(\\n      ds.facetFunctionSelectors[_facetAddress].functionSelectors.length\\n    );\\n    // add new facet address if it does not exist\\n    if (selectorPosition == 0) {\\n      addFacet(ds, _facetAddress);\\n    }\\n    for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\n      bytes4 selector = _functionSelectors[selectorIndex];\\n      address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\\n      require(\\n        oldFacetAddress != _facetAddress,\\n        \\\"LibDiamondCut: Can't replace function with same function\\\"\\n      );\\n      removeFunction(ds, oldFacetAddress, selector);\\n      addFunction(ds, selector, selectorPosition, _facetAddress);\\n      selectorPosition++;\\n    }\\n  }\\n\\n  function removeFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\\n    require(_functionSelectors.length > 0, 'LibDiamondCut: No selectors in facet to cut');\\n    DiamondStorage storage ds = diamondStorage();\\n    // if function does not exist then do nothing and return\\n    require(_facetAddress == address(0), 'LibDiamondCut: Remove facet address must be address(0)');\\n    for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\n      bytes4 selector = _functionSelectors[selectorIndex];\\n      address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\\n      removeFunction(ds, oldFacetAddress, selector);\\n    }\\n  }\\n\\n  function addFacet(DiamondStorage storage ds, address _facetAddress) internal {\\n    enforceHasContractCode(_facetAddress, 'LibDiamondCut: New facet has no code');\\n    ds.facetFunctionSelectors[_facetAddress].facetAddressPosition = ds.facetAddresses.length;\\n    ds.facetAddresses.push(_facetAddress);\\n  }\\n\\n  function addFunction(\\n    DiamondStorage storage ds,\\n    bytes4 _selector,\\n    uint96 _selectorPosition,\\n    address _facetAddress\\n  ) internal {\\n    ds.selectorToFacetAndPosition[_selector].functionSelectorPosition = _selectorPosition;\\n    ds.facetFunctionSelectors[_facetAddress].functionSelectors.push(_selector);\\n    ds.selectorToFacetAndPosition[_selector].facetAddress = _facetAddress;\\n  }\\n\\n  function removeFunction(\\n    DiamondStorage storage ds,\\n    address _facetAddress,\\n    bytes4 _selector\\n  ) internal {\\n    require(_facetAddress != address(0), \\\"LibDiamondCut: Can't remove function that doesn't exist\\\");\\n    // an immutable function is a function defined directly in a diamond\\n    require(_facetAddress != address(this), \\\"LibDiamondCut: Can't remove immutable function\\\");\\n    // replace selector with last selector, then delete last selector\\n    uint256 selectorPosition = ds.selectorToFacetAndPosition[_selector].functionSelectorPosition;\\n    uint256 lastSelectorPosition = ds\\n      .facetFunctionSelectors[_facetAddress]\\n      .functionSelectors\\n      .length - 1;\\n    // if not the same then replace _selector with lastSelector\\n    if (selectorPosition != lastSelectorPosition) {\\n      bytes4 lastSelector = ds.facetFunctionSelectors[_facetAddress].functionSelectors[\\n        lastSelectorPosition\\n      ];\\n      ds.facetFunctionSelectors[_facetAddress].functionSelectors[selectorPosition] = lastSelector;\\n      ds.selectorToFacetAndPosition[lastSelector].functionSelectorPosition = uint96(\\n        selectorPosition\\n      );\\n    }\\n    // delete the last selector\\n    ds.facetFunctionSelectors[_facetAddress].functionSelectors.pop();\\n    delete ds.selectorToFacetAndPosition[_selector];\\n\\n    // if no more selectors for facet address then delete the facet address\\n    if (lastSelectorPosition == 0) {\\n      // replace facet address with last facet address and delete last facet address\\n      uint256 lastFacetAddressPosition = ds.facetAddresses.length - 1;\\n      uint256 facetAddressPosition = ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\\n      if (facetAddressPosition != lastFacetAddressPosition) {\\n        address lastFacetAddress = ds.facetAddresses[lastFacetAddressPosition];\\n        ds.facetAddresses[facetAddressPosition] = lastFacetAddress;\\n        ds.facetFunctionSelectors[lastFacetAddress].facetAddressPosition = facetAddressPosition;\\n      }\\n      ds.facetAddresses.pop();\\n      delete ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\\n    }\\n  }\\n\\n  function initializeDiamondCut(address _init, bytes memory _calldata) internal {\\n    if (_init == address(0)) {\\n      return;\\n    }\\n    enforceHasContractCode(_init, 'LibDiamondCut: _init address has no code');\\n    (bool success, bytes memory error) = _init.delegatecall(_calldata);\\n    if (!success) {\\n      if (error.length > 0) {\\n        // bubble up error\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n          let returndata_size := mload(error)\\n          revert(add(32, error), returndata_size)\\n        }\\n      } else {\\n        revert InitializationFunctionReverted(_init, _calldata);\\n      }\\n    }\\n  }\\n\\n  function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\\n    uint256 contractSize;\\n    assembly {\\n      contractSize := extcodesize(_contract)\\n    }\\n    require(contractSize > 0, _errorMessage);\\n  }\\n}\\n\",\"keccak256\":\"0x341f5cbd88d747bcd5beb54a939ddfb8111d04b7a28b1071a4f2a8e4fcfdd216\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b5061058d806100206000396000f3fe608060405234801561001057600080fd5b506004361061002b5760003560e01c80636e02fa3c14610030575b600080fd5b61004361003e3660046102bf565b610045565b005b82811461008d576040517f7340e16600000000000000000000000000000000000000000000000000000000815260048101849052602481018290526044015b60405180910390fd5b60005b83811015610132576101208585838181106100ad576100ad61032b565b90506020020160208101906100c2919061035a565b8484848181106100d4576100d461032b565b90506020028101906100e69190610397565b8080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525061013992505050565b8061012a816103fc565b915050610090565b5050505050565b73ffffffffffffffffffffffffffffffffffffffff8216610158575050565b61017a8260405180606001604052806028815260200161053060289139610238565b6000808373ffffffffffffffffffffffffffffffffffffffff16836040516101a2919061047f565b600060405180830381855af49150503d80600081146101dd576040519150601f19603f3d011682016040523d82523d6000602084013e6101e2565b606091505b509150915081610232578051156101fc5780518082602001fd5b83836040517f192105d70000000000000000000000000000000000000000000000000000000081526004016100849291906104e5565b50505050565b813b8181610232576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610084919061051c565b60008083601f84011261028557600080fd5b50813567ffffffffffffffff81111561029d57600080fd5b6020830191508360208260051b85010111156102b857600080fd5b9250929050565b600080600080604085870312156102d557600080fd5b843567ffffffffffffffff808211156102ed57600080fd5b6102f988838901610273565b9096509450602087013591508082111561031257600080fd5b5061031f87828801610273565b95989497509550505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b60006020828403121561036c57600080fd5b813573ffffffffffffffffffffffffffffffffffffffff8116811461039057600080fd5b9392505050565b60008083357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe18436030181126103cc57600080fd5b83018035915067ffffffffffffffff8211156103e757600080fd5b6020019150368190038213156102b857600080fd5b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8203610454577f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b5060010190565b60005b8381101561047657818101518382015260200161045e565b50506000910152565b6000825161049181846020870161045b565b9190910192915050565b600081518084526104b381602086016020860161045b565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169290920160200192915050565b73ffffffffffffffffffffffffffffffffffffffff83168152604060208201526000610514604083018461049b565b949350505050565b602081526000610390602083018461049b56fe4c69624469616d6f6e644375743a205f696e6974206164647265737320686173206e6f20636f6465a26469706673582212207217874a568487a84b449cfcde224e682e91046cff0b82dce5306796edc09e1864736f6c63430008130033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b506004361061002b5760003560e01c80636e02fa3c14610030575b600080fd5b61004361003e3660046102bf565b610045565b005b82811461008d576040517f7340e16600000000000000000000000000000000000000000000000000000000815260048101849052602481018290526044015b60405180910390fd5b60005b83811015610132576101208585838181106100ad576100ad61032b565b90506020020160208101906100c2919061035a565b8484848181106100d4576100d461032b565b90506020028101906100e69190610397565b8080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525061013992505050565b8061012a816103fc565b915050610090565b5050505050565b73ffffffffffffffffffffffffffffffffffffffff8216610158575050565b61017a8260405180606001604052806028815260200161053060289139610238565b6000808373ffffffffffffffffffffffffffffffffffffffff16836040516101a2919061047f565b600060405180830381855af49150503d80600081146101dd576040519150601f19603f3d011682016040523d82523d6000602084013e6101e2565b606091505b509150915081610232578051156101fc5780518082602001fd5b83836040517f192105d70000000000000000000000000000000000000000000000000000000081526004016100849291906104e5565b50505050565b813b8181610232576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610084919061051c565b60008083601f84011261028557600080fd5b50813567ffffffffffffffff81111561029d57600080fd5b6020830191508360208260051b85010111156102b857600080fd5b9250929050565b600080600080604085870312156102d557600080fd5b843567ffffffffffffffff808211156102ed57600080fd5b6102f988838901610273565b9096509450602087013591508082111561031257600080fd5b5061031f87828801610273565b95989497509550505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b60006020828403121561036c57600080fd5b813573ffffffffffffffffffffffffffffffffffffffff8116811461039057600080fd5b9392505050565b60008083357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe18436030181126103cc57600080fd5b83018035915067ffffffffffffffff8211156103e757600080fd5b6020019150368190038213156102b857600080fd5b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8203610454577f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b5060010190565b60005b8381101561047657818101518382015260200161045e565b50506000910152565b6000825161049181846020870161045b565b9190910192915050565b600081518084526104b381602086016020860161045b565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169290920160200192915050565b73ffffffffffffffffffffffffffffffffffffffff83168152604060208201526000610514604083018461049b565b949350505050565b602081526000610390602083018461049b56fe4c69624469616d6f6e644375743a205f696e6974206164647265737320686173206e6f20636f6465a26469706673582212207217874a568487a84b449cfcde224e682e91046cff0b82dce5306796edc09e1864736f6c63430008130033",
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}